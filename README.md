项目开发时间：

```
2023年8月21日-2023年8月22日
```

项目名称：

```
基于GEC6818五子棋游戏
```

项目文件名称：gomoku

```
子文件夹及其子文件：
		（1）文件夹：photo(保存BMP图片)
			1.background.bmp
			2.blackwin.bmp
			3.menu.bmp
			4.quit.bmp
			5.whitewin.bmp
			6.black.bmp
			7.white.bmp
			8.peace.bmp
			9.nogame.bmp

	  (2).文件：Gomoku(主程序)
```

项目需求：

```
	（1）带有主菜单，在主菜单上提供开始游戏，查看排行榜和退出选项
	（2）五子棋游戏的基础玩法，黑白子交替落棋，判断胜负，判断棋盘是否已满（平局）
	（3）提供排行榜功能，显示当前双方玩家的胜局排行榜
	（4）提供退出按钮，结束程序
	   扩展：
	（1）游戏界面提供返回主菜单选项，可以提前结束对局
	（2）判断胜负时，显示游戏胜负
```

项目大致框架：

```
	（1）GEC6818开发板LCD屏幕的初始化
	（2）读取BMP图片文件信息，并显示在LCD屏幕上
	（3）获取GEC6818开发板输入子事件
	（4）判断输入子事件，实现点击功能
	（5）五子棋的基础玩法，胜负判定和棋局判断（平局判断）
	（6）主菜单界面
	（7）排行榜界面
	（8）程序退出
```

项目程序函数：
	

```
（1）int main()//主函数：

			执行程序，先对LCD屏幕进行初始化，再执行主菜单界面；

（2）void draw_menu()//主菜单界面模块：

			绘制主菜单界面，并提供开始游戏，查看排行榜，退出程序三个选项，用户可通过点击选项方框进行功能选择；

  重点：为保证程序持续运行，在主菜单界面进行while(1)死循环，只有当用户主动选择退出程序选项才会结束程序运行；

（3）void lcd_Init()//屏幕初始化模块：

			对GEC6818LCD屏进行文件打开"dev/fb0"，读取文件属性数据（像素点数量），并对文件进行映射生成。 （mmap）;

（4）void lcd_draw(int x,int y,int color)//绘制模块：

			对GEC6818LCD屏进行单个像素颜色显示，三个输入参数分别表示像素点X坐标，像素点Y坐标，显示颜色；通过对映射文件指向地址的数据进行修改；

   重点：通过对映射文件指向的首地址进行偏移，可更方便更令人理解地进行单个像素点颜色显示

（5）void bmp_draw(int x,int y,const char *bmppath)//读取并绘制bmp文件模块：

			三个输入参数分别表示X轴偏移量，Y轴偏移量，指定BMP文件存储地址。通过对访问打开指定BMP文件，并对其进行文件属性判断，文件属性数据获取（图片宽和高和色深以及是否有填充量fill），并对其属性内容进行数据还原（小端模式数据变成大端模式数据），通过在该函数内引用了【void lcd_Init()//屏幕初始化模块】，完成用户自定义X和Y轴偏移让该图片显示在开发板LCD屏上。

  重点：文件数据在计算机存储方式为小端模式，但人类阅读习惯为大端模式，于是要将文件属性数据进行还原。同时通过对该图片色深的判断，即24位还是32位。判断是RGB模式还是ARGB模式。在对ARGB/RGB数据的还原上，可采用对一个指针进行空间开辟，或者创建一个二维数组对象进行对RGB数据内容的存储，同时还要每一行判断是否有存在填充量fill的存在，如果存在，需要每一行跳过填充量fill；

  难点：在对ARGB/RGB数据的获取上，第一次采用了对一个指针对象进行空间开辟的形式，但在指针偏移过程中采用了对指针指向的地址后自增的算法（*color_point++），导致了虽然能获取ARGB/RGB数据但是出现了指针越界以及指针空间释放错误的情况，即free()释放了其他空间    （产生报错：munmap_chunk(): invalid pointer）；后通过排查，改正了这一错误，使用创建整形对象int i，对指针进行下标访问以及下标后自增偏移（color_point[i++]），这样做即保证了ARGB/RGB数据的正常获取也保证了正常的空间开辟和空间释放；

（6）void lcd_event()//获取输入子事件模块：
	

			打开输入子事件文件地址"/dev/input/event0"，通过用结构体类型struct input_event定义一个ev变量，通过读取输入子事件文件的数据内容存放在变量对象ev内，然后对ev内容进行条件判断，令其能够判别点击来获取点击X和Y坐标，存放在全局整型变量int outx,outy内；

	重点：点击事件的判定条件是先判定触摸LCD屏事件，并保存触碰坐标；直到点击事件完成后，通过判定条件完成outx和outy保存特定的X和Y轴坐标；

对应代码：
   if(ev.type == EV_ABS) // 绝对事件
        {
            // 获取X轴的数值
            if(ev.code == ABS_X)
            {
                x = ev.value*0.78;
            }
        }
        if(ev.type == EV_ABS) // 绝对事件
        {
            // 获取X轴的数值
            if(ev.code == ABS_Y)
            {
                y = ev.value*0.78;
            }
        }
            // 判断压感
        if(ev.type == EV_KEY && ev.code == BTN_TOUCH && ev.value == 0)
        {
            outx=x;
            outy=y;
            return;
        }
        

（7）void person_person()//游戏对战模块：

			实现五子棋游戏的基本玩法；首先进行棋盘背景绘制，游戏默认黑子先下，用一个整形变量step记录步数，同时通过判断奇偶性来判定黑子白子落棋，将棋盘数据存放在一个15*15的二维数组内，同时对该二维数组进行初始化为0；用0代表空，1代表黑棋，-1代表白棋。通过调用【void lcd_event()//获取输入子事件模块】，再通过坐标判断，来判断该点击处是否能落棋；，落棋后进行棋子的绘制，然后判断胜负，若未分出胜负则继续交替落棋，同时每次落棋后进行平局判断；

重点：交替下棋的输入子事件判断；对黑白子的绘制；胜负结算界面的绘制以及平局界面的绘制

难点：交替下棋的输入子事件判断：先计算出第一个落点的X和Y轴坐标（像素坐标），并计算出每个格子的距离，以每个横竖交叉的格子为中心，对外进行X和Y轴扩散20像素点，以便点击效率更高；
          绘制黑白子的的方法：依旧以每个横竖交叉的点为中心点，向外绘制一个半径为10的圆，引用【void lcd_draw(int x,int y,int color)//绘制模块】进行黑白子的绘制；
          

（8）int is_full(int chessboard[SIZE][SIZE])//判断棋盘是否已满模块：

			输入参数为保存棋盘数据的二维数组，通过对该二维数组的遍历，遍历数据内是否有BANK（即0）的存在，如果存在则表示未满，返回0表示未满；返回1表示已满。


（9）int is_win(int chessboardSIZE, int row, int col)//判断胜负模块：

			输入参数分别为为存放棋盘数据的二维数组，二维数组的行，二维数组的列；通过对棋盘的遍历，判断每个数据与其连续四组横和竖和左斜和右斜数据，进行胜负判定的条件，如满足，则返回胜利方所代表的整数（1表示黑子胜利，-1表示白子胜利，0表示胜负未分）

重点：胜负判定的条件


（10）void quit()//退出程序模块：

			关闭程序，并显示退出游戏的图像

重点：退出程序时需要把打开的文件关闭，把映射的文件进行关闭，同时显示图像，并且用exit(0)退出程序


（11）void options()//排行榜模块：

	用两个整型对象int blackwin,whitewin表示黑白方的胜利次数，通过判断大小来进行排行榜排序
```



项目遇到过的问题：

```
（1）在对ARGB/RGB数据的获取上，第一次采用了对一个指针对象进行空间开辟的形式，但在指针偏移过程中采用了对指针指向的地址后自增的算法（*color_point++），导致了虽然能获取ARGB/RGB数据但是出现了指针越界以及指针空间释放错误的情况，即free()释放了其他空间（产生报错：munmap_chunk(): invalid pointer）；后通过排查，改正了这一错误，使用创建整形对象int i，对指针进行下标访问以及下标后自增偏移（color_point[i++]），这样做即保证了ARGB/RGB数据的正常获取也保证了正常的空间开辟和空间释放；

（2）如何让点击子事件与二维数组的相应位置进行关联：采用的方法是通过对点击事件发生的坐标进行特定数值相除，即ROW=outy/30;COL=outx/37(30和37是通过对棋盘横竖交叉点的计算所得的)，获取点击子事件和二维数组对应下标的关系；
```

项目不足之处：



```
（1）对于整个五子棋项目，目前只采用了单个文件多个函数封装来实现，即采用了不同函数并提供函数接口，来对该项目进行模块化设计，但在设计时疏忽了对文件的模块化设计，故导致整个项目的程序文件只有Gomoku.c，并对其进行交叉编译成Gomoku；导致了该项目的可读性和模块化有一定的不足之处；

（2）排行榜的设计应该可以通过对printf重定向的方式进行具体胜局的显示，但目前项目只采用了判断大小的方式进行排行；

（3）黑白棋子的绘制其实可以采用BMP图片的方式进行更精细的绘制，但对于BMP图片的尺寸和绘制方式过于复杂，故目前项目采用的是颜色绘制，精细度存在一定的不足之处；

```

